# Coroutines
- defines scope eg GlobalScope.launch {}
- inside scope you can suspend for some time by calling delay(3000L)
- if main thread finishes its work all threads will stop
- Suspend functions can only be called within a coroutine or another suspend function
- Suspend functions execute sequentially within a coroutine unless other wise
- Dispatchers given extra info to the context in which the coroutine runs
- Main dispature will run on the main thread, IO will do IO operations and network calls, Unconfined and Default(very long operations and tasks)
- withContext(Dispatcher.Main) will help us switch between threads for a particular coroutine
- a delay() in runBlocking() context will block the main thread but not in Dispatchers.Main context
- runBlocking will only Affect the main thread, other coroutine scopes launched inside it will run normally(Asyncronously) 
- Launching a coroutine always returns a `job` which can be saved in a val
- The `job.join()` will wait for the `job` to finish.
- `job.cancel()` will cancel the coroutine
- sometimes if for long running jobs the coroutine continues even after its canceled to prevent this check `isActive()`